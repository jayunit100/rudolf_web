<p>Here are some of the git commands that I find most useful, covering
configuration, staging, and history:</p>


<h2>Configuration</h2>
<pre class="code">
# change settings for all users
#   affects file in /etc/gitconfig
git config --system [??].[attribute] [value]

# change settings for one user
#   affects file in $HOME/.gitconfig
git config --global [??].[attribute] [value]

# change settings for one project
#   affects file in [projectroot]/.git/config
git config [??].[attribute] [value]

# change editor
git config core.editor emacs

# check all settings
git config --list

# check specific setting
git config [??].[attribute]
</pre>


<h2>Staging area</h2>
<pre class="code">
# remove file from staging area
git rm --cached [file]

# see diff of files in staging area
git diff --staged

# see tracked files
git ls-files

# see information about tree-ish objects
#   what is a tree-ish object?  the man page doesn't explain it
git ls-tree [sha-1] [path]
</pre>


<h2>History</h2>
<pre class="code">
# see a "pretty" commit history
#   setting: (oneline|short|full|fuller|format:"format string").  note that the --pretty option can interfere with other log options
git log --pretty=[setting]

# see only a limited number of commits
#   accepts any (?) positive integer
git log -[n]

# show diffs with each commit
git log -p
 
# see history of a specific file
#   is this any different from just 'git log [file]'?
git log --follow [file]

# see a branch graph
git log --graph

# display file statistics with each commit:  number of additions, deletions, etc. 
#   see also --shortstat ??
git log --stat

# more log options
git log (--name-only|--name-status|--abbrev-commit|--relative-date|--since|--until|--grep)

# make *all* criteria match
#   instead of *any* predicate causing a match, *all* predicates must be true to match
git log --all-match [... conditions ...]

# show only/don't show merge commits
git log --merges
git log --no-merges
</pre>


<h2>Miscellaneous</h2>
<pre class="code">
# amend previous commit.  uses staging area for commit
#   what happens with sha-1 business?  does this command take more arguments (i.e. for commit message)?
git commit --amend
 
# make a command alias
#   ... not sure if those are supposed to be quotation marks or backticks or what ...
git config --global alias.[thealias] ['the original command']
</pre>



Tricks:

 - auto-completion:  copy contrib/completion/git-completion.bash (look in the git source code?) into your home
   directory and 'source' it into your .bashrc file.  then copy to '/opt/local/etc/bash_completion.d' (Mac) or
   '/etc/bash_completion.d/' (Linux).  then it will tab-complete.  also works with options (i.e. git log --\t)



questions:

 - in .gitignore, if you have a pattern that says don't include, and another that contradicts it, who wins?

 - how many characters needed to identify an sha-1 key?  (seems to complain if ambiguous)
 
 - what is a tracking branch
 
 <p>In this second part of the article, we'll see more of the git commands
that I find most useful, covering remotes, tags, and rebasing:</p>


<h2>Remote</h2>
<pre class="code">
# see remotes
git remote -v

# make a new remote
git remote add [name] [location]

# get data from a remote -- everything that you don't yet have locally
git fetch [remote]

# show info about a remote
git remote show [remote]

# rename a remote (i.e. change the local alias -- doesn't change anything on the actual remote server)
#   also renames remote branch names
git remote rename [old] [new]
 
# remove a remote
git remote rm [remote]
</pre>


<h2>Tags</h2>
<pre class="code">
# see all tags
git tag

# see tags matching a pattern
#   this doesn't seem to work
git tag -l [pattern]

# make a lightweight tag
git tag [tagname]

# make an annotated tag
#   what does '-a' do?
git tag -a [tagname] -m 'commit message'
 
# show a single tag
git show [tagname]

# make a signed tag
git tag -s [tagname] -m 'commit message'

# verify a signed tag
#   need signer's public key ... somewhere?  in keyring?
git tag -v [tagname]
 
# make a tag of a previous commit
git tag -a [tagname] [commit's sha-1 checksum]

# push one tag to a remote
git push [remote] [tagname]

# push all tags to a remote
git push [remote] --tags
</pre>


<h2>Rebasing</h2>
<pre class="code">
# rebase the current branch onto another branch
git rebase [base-branch]

# rebase a branch onto another branch
git rebase [base-branch] [rebasee-branch]

# typical rebasing workflow:
#   switch to rebasee
git checkout [rebasee-branch]
#   put rebasee on base
git rebase [base-branch]
#   switch to base
git checkout [base-branch]
#   fast-forward merge rebasee into base 
git merge [rebasee-branch]

# more complicated rebase ... don't understand it
git rebase --onto [base-branch] [upstream-branch] [rebasee-branch]
</pre>